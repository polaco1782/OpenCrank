/*
 * OpenCrank C++11 - Memory Manager Implementation
 * 
 * High-level memory management. Coordinates the SQLite store
 * and provides a clean interface for memory and task operations.
 */
#include <opencrank/memory/manager.hpp>
#include <opencrank/core/config.hpp>
#include <opencrank/core/logger.hpp>

#include <cstdlib>

namespace opencrank {

// ============================================================================
// MemoryManager Implementation
// ============================================================================

MemoryManager::MemoryManager() : initialized_(false) {}

MemoryManager::~MemoryManager() {
    shutdown();
}

bool MemoryManager::init(const MemoryConfig& config) {
    if (initialized_) {
        shutdown();
    }
    
    config_ = config;
    
    // Resolve database path
    std::string db_path = config_.db_path;
    if (db_path.empty()) {
        db_path = ".opencrank/memory.db";
    }
    
    LOG_INFO("[MemoryManager] Initializing with db_path=%s", db_path.c_str());
    
    if (!store_.open(db_path)) {
        LOG_ERROR("[MemoryManager] Failed to open database: %s", db_path.c_str());
        return false;
    }
    
    initialized_ = true;
    LOG_INFO("[MemoryManager] Initialized successfully");
    return true;
}

bool MemoryManager::init(const Config& config) {
    MemoryConfig mcfg;
    
    mcfg.db_path = config.get_string("memory_db_path", "");
    if (mcfg.db_path.empty()) {
        mcfg.db_path = config.get_string("memory.db_path", ".opencrank/memory.db");
    }
    
    mcfg.workspace_dir = config.get_string("workspace_dir", ".");
    
    mcfg.chunking.target_tokens = static_cast<int>(
        config.get_int("memory.chunk_tokens", 400));
    mcfg.chunking.overlap_tokens = static_cast<int>(
        config.get_int("memory.chunk_overlap", 80));
    mcfg.search.max_results = static_cast<int>(
        config.get_int("memory.max_results", 10));
    
    return init(mcfg);
}

void MemoryManager::shutdown() {
    if (initialized_) {
        store_.close();
        initialized_ = false;
        LOG_INFO("[MemoryManager] Shut down");
    }
}

// ============================================================================
// Memory Operations
// ============================================================================

std::string MemoryManager::save_memory(
    const std::string& content,
    const std::string& category,
    int importance,
    const std::string& tags,
    const std::string& channel,
    const std::string& user_id)
{
    if (!initialized_) {
        LOG_ERROR("[MemoryManager] Not initialized, cannot save memory");
        return "";
    }
    
    MemoryEntry entry;
    // ID will be generated by store
    entry.content = content;
    entry.category = category;
    entry.importance = importance;
    entry.tags = tags;
    entry.channel = channel;
    entry.user_id = user_id;
    
    if (store_.save_memory(entry)) {
        // Return a confirmation - the store generates the ID internally
        LOG_DEBUG("[MemoryManager] Memory saved (category=%s, importance=%d)",
                  category.c_str(), importance);
        return "saved";
    }
    
    return "";
}

std::vector<MemorySearchHit> MemoryManager::search(
    const std::string& query, int max_results, const std::string& category)
{
    if (!initialized_) {
        LOG_WARN("[MemoryManager] Not initialized, cannot search");
        return std::vector<MemorySearchHit>();
    }
    
    int limit = max_results > 0 ? max_results : config_.search.max_results;
    return store_.search_memories(query, limit, category);
}

MemoryEntry MemoryManager::get_memory(const std::string& id) {
    if (!initialized_) return MemoryEntry();
    return store_.get_memory(id);
}

std::vector<MemoryEntry> MemoryManager::get_recent(int limit, const std::string& category) {
    if (!initialized_) return std::vector<MemoryEntry>();
    return store_.get_recent_memories(limit, category);
}

bool MemoryManager::delete_memory(const std::string& id) {
    if (!initialized_) return false;
    return store_.delete_memory(id);
}

// ============================================================================
// Task Operations
// ============================================================================

std::string MemoryManager::create_task(
    const std::string& content,
    const std::string& context,
    int64_t due_at,
    const std::string& channel,
    const std::string& user_id)
{
    if (!initialized_) {
        LOG_ERROR("[MemoryManager] Not initialized, cannot create task");
        return "";
    }
    
    MemoryTask task;
    // ID will be generated by store
    task.content = content;
    task.context = context;
    task.due_at = due_at;
    task.channel = channel;
    task.user_id = user_id;
    
    if (store_.create_task(task)) {
        LOG_DEBUG("[MemoryManager] Task created: '%.50s'", content.c_str());
        return "created";
    }
    
    return "";
}

std::vector<MemoryTask> MemoryManager::list_tasks(
    bool include_completed, const std::string& channel)
{
    if (!initialized_) return std::vector<MemoryTask>();
    return store_.list_tasks(include_completed, channel);
}

MemoryTask MemoryManager::get_task(const std::string& id) {
    if (!initialized_) return MemoryTask();
    return store_.get_task(id);
}

bool MemoryManager::complete_task(const std::string& id) {
    if (!initialized_) return false;
    return store_.complete_task(id);
}

bool MemoryManager::delete_task(const std::string& id) {
    if (!initialized_) return false;
    return store_.delete_task(id);
}

std::vector<MemoryTask> MemoryManager::get_due_tasks() {
    if (!initialized_) return std::vector<MemoryTask>();
    return store_.get_due_tasks();
}

} // namespace opencrank
